// Copyright (c) 2014 Dataence, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"compress/gzip"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"time"
)

type node struct {
	b byte    // node value
	f bool    // end of string
	s int     // state
	c []*node // children
	m int     // suffix length
	w string  // suffix
}

func inputFile(fname string) (*bufio.Scanner, *os.File) {
	var s *bufio.Scanner

	f, err := os.Open(fname)
	if err != nil {
		log.Fatal(err)
	}

	if strings.HasSuffix(fname, ".gz") {
		gunzip, err := gzip.NewReader(f)
		if err != nil {
			log.Fatal(err)
		}

		s = bufio.NewScanner(gunzip)
	} else {
		s = bufio.NewScanner(f)
	}

	return s, f
}

func outputFile(fname string) *os.File {
	var (
		ofile *os.File = os.Stdin
		err   error
	)

	if fname != "" {
		// Open output file
		ofile, err = os.OpenFile(fname, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0600)
		if err != nil {
			log.Fatal(err)
		}
	}

	return ofile
}

func main() {
	flag.Parse()
	if len(flag.Args()) != 2 {
		log.Fatal("Invalid command. Must be 'xtldfsm <infile> <outfile>.'")
	}

	in, ifile := inputFile(flag.Arg(0))
	defer ifile.Close()

	ofile := outputFile(flag.Arg(1))
	defer ofile.Close()

	fmt.Fprintf(ofile, `// Copyright (c) 2014 Dataence, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is automatically generated by xtldfsm.go. Please DO NOT modify.
// This file was generated at %s.

package xtld

// TLD extracts the top-level-domain based on data from
// https://www.publicsuffix.org/list/effective_tld_names.dat
func TLD(ss string) string {
	m := TLDlen(ss)
	return ss[len(ss)-m:]
}

// TLDlen determins the length of the TLD
func TLDlen(ss string) int {
	var (
		l int = len(ss)	// string length
		m int			// suffix length
		s int			// state
		b byte			// current byte
	)

loop:
	for i := 0; i < l; i++ {
		b = ss[l-i-1]

		switch s {
`, time.Now())

	s := 0 // state
	root := &node{s: s}
	nodes := append(make([]*node, 0, 10), root)

	for in.Scan() {
		ss := in.Text()
		ss = strings.TrimSpace(ss)
		if len(ss) == 0 {
			continue
		}

		if ss[:2] == "//" {
			continue
		}

		cur := root

		for i := len(ss) - 1; i >= 0; i-- {
			b := ss[i]
			found := false
			var n *node

			for _, n = range cur.c {
				if n.b == b {
					found = true
					break
				}
			}

			if !found {
				s++
				n = &node{b: b, s: s}
				cur.c = append(cur.c, n)
				nodes = append(nodes, n)
			}

			cur = n
			if i == 0 {
				n.m = len(ss)
				n.w = ss
				n.f = true
			}
		}
	}

	for _, n := range nodes {
		if len(n.c) > 0 {
			fmt.Fprintf(ofile, "\t\tcase %d:\n", n.s)
			fmt.Fprintf(ofile, "\t\t\tswitch b {\n")

			for _, c := range n.c {
				fmt.Fprintf(ofile, "\t\t\tcase '%c':\n", c.b)
				fmt.Fprintf(ofile, "\t\t\t\ts = %d\n", c.s)
				if c.f {
					fmt.Fprintf(ofile, "\t\t\t\tm = %d\n", c.m)
					fmt.Fprintf(ofile, "\t\t\t\t// %s - final\n", c.w)
				}
			}

			fmt.Fprintf(ofile, "\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t}\n")
		}
	}

	fmt.Fprintln(ofile, `		default:
			break loop
		}
	}

	if m != l && ss[l-m-1] != '.' {
			return 0
	}
	return m
}`)
}
